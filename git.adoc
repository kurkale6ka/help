== Commits

commit 98ca9
- metadata (author, date, ...)
- previous commits
- tree 92ec2 (index snapshot)

tree 92ec2
- blob 5b1d3 README
- blob 911e7 LICENSE

objects
- blob 5b1d3 README contents
- blob 911e7 LICENSE contents

== Branches

`git branch -vv`

a branch is a pointer to a commit
HEAD points to the current branch # git checkout br1 moves HEAD to br1
The HEAD branch moves forward when a commit is made

git ls-remote origin -> refs/heads/master # heads refers to 'branches'

== Track a remote(-tracking) branch (e.g origin/master)

you do that in order to use git pull/push without arguments (implied origin + remote)

note:: origin/master is called a remote-tracking branch.
       it's a local reference/pointer that can't be moved

 git checkout -b <branch> <remote>/<branch>
 git checkout --track origin/serverfix
 git checkout serverfix

 git branch -u origin/serverfix
 git push -u origin my-branch # set origin/my-branch (@{u[pstream]}) as upstream for my-branch

 git push origin serverfix
 git push origin serverfix:serverfix
 git push origin refs/heads/serverfix:refs/heads/serverfix

== Index aka staging area

Everything tracked is in your staging area - the index.

git rm
------
    removes from both the index and the working copy

git rm --cached
    removes from the index only => untracks the file!

git commit --amend
------------------
    change the message of the previous commit + add any staged files
    same as git reset --soft HEAD^, change index, then git commit

== git reset

=== reset with a ref but without a path

1. move `HEAD`
2. update index: _stop here by default (change with --*soft*/*hard*)_
3. optionally update the working dir

HEAD (--soft)  ⇒  Index  ⇒  Working dir (--hard)

example: `git reset HEAD~`::
    * move HEAD+branch to previous commit => undo last commit
    * update index with the snapshot HEAD+branch point to => unstage everything

=== reset with a path

git reset file::
    unstage file (opposite of git add file)
git reset::
    unstage all files
git reset --hard::
    unstage everything + reset working dir

git rebase
----------
git rebase -i HEAD~5 # interactive

git add
-------
git add -p # only add chosen hunks for this commit

git config
----------
git config --global user.name 'Dimitar Dimitrov'
git config --global user.email mitkofr@yahoo.fr

git config --global core.excludesfile "$HOME"/.gitignore
git config --global core.editor "vim -u $HOME/.vimrc"
git config --global color.ui true

# make 'git pull' on master always use rebase
# git config branch.master.rebase true

# setup rebase for every tracking branch
git config --global branch.autosetuprebase always

git config --global diff.tool vimdiff
git config --global difftool.prompt false

git config --global alias.d difftool
git config --global alias.df diff
git config --global alias.co checkout
git config --global alias.ci commit
git config --global alias.msg 'log -1 --pretty=\%B'
git config --global pager.msg false
git config --global alias.sha "rev-parse HEAD"
git config --global alias.st status
git config --global alias.br branch
git config --global alias.l "log --date=short --pretty=format:'%C(yellow)%h%C(reset) %C(green)%ad%C(reset) %C(blue)%an%C(reset) | %s %C(red)%d%C(reset)'"
git config --global alias.lg "log --graph --date=short --pretty=format:'%C(yellow)%h%C(reset) %C(green)%ad%C(reset) %C(blue)%an%C(reset) | %s %C(red)%d%C(reset)'"
git config --global alias.type cat-file -t
git config --global alias.dump cat-file -p

alias gc='git commit -v'
alias gp='git push origin master'
alias gs='git status -sb'
alias go='git checkout'
alias gm='git checkout master'
alias ga='git add'
alias gb='git branch'
alias gd='git diff --word-diff=color'
alias gf='git fetch'
alias gl='git log --oneline --decorate'
alias gll='git log -U1 --word-diff=color' # -U1: 1 line of context (-p implied)

git checkout
------------
git checkout -b topic master
git branch topic master && git checkout topic
    create topic from local master and check it out

git push
--------
git push origin serverfix
git push origin serverfix:serverfix
git push origin refs/heads/serverfix:refs/heads/serverfix
                               local:remote

After a git fetch that brings origin/serverfix (upstream or @{u}),
is git checkout -b serverfix origin/serverfix equivalent to
   git checkout --track origin/serverfix
   git checkout serverfix

Those create a tracking branch => git pull knows what server/branch to pull from

Set current branch to track:
    git branch -u origin/serverfix

Rename a branch
---------------
git branch -m new
git push origin :old   # delete the remote branch
git push -u origin new # push and track the new branch

Make an existing Git branch track a remote branch
-------------------------------------------------

git branch -u origin/foo

Submodules
----------
Add
git submodule add git@github.com:tpope/vim-commentary.git bundle/vim-commentary

Delete
{
mods=()
mods+=("")
for m in "${mods[@]}"
do
   # rm -rf bundle/"$m"
   git submodule deinit bundle/"$m"
   git rm bundle/"$m"
   rm -rf .git/modules/bundle/"$m"
done
}

Update:
all
git submodule foreach git pull origin master

only one
cd $my_submodule && git pull # OR
git -C my_submodule pull

Cloning a Project with Submodules:
Activate the submodules with:
git submodule init
git submodule update

Rename:
1. Delete the relevant section from the .gitmodules file
2. git add .gitmodules
3. Delete the relevant section from .git/config
4. git rm --cached bundle/_my/\* (no trailing slash)
5. rm -rf .git/modules/bundle/_my/*
6. rm -rf bundle/_my/
7. git submodule add git@github.com:kurkale6ka/vim-swap.git .bundle/swap

== Annexe

HEAD~ is the same as HEAD^ which is the parent commit of HEAD
