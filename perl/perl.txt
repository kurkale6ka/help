statement -> code;
expression -> $var = code; # code that returns a value

Scalars

my ($a, $b, $c) = @array; # multiple assignements

Arrays

@items = ('string', $scalar, 12);
@items = qw/one two three/;

@items # number of elements

@items[1..$#items] # slice: all bar 1st

@upper_case = map uc, @items; # change a list
@list = grep '[-_]', @items; # filter a list

shift, pop # remove elements
unshift, push # add elements

print @items   # $, - print's field separator; $\ is the record separator only printed after print's last argument
print "@items" # $" - list separator for interpolation

# merge 2 arrays and keep elements unique
1. my @unique = uniq(@array1, @array2); # use List::Util qw(uniq);
2. my @merged{@array1, @array2} = ();
3. my %merged = map { $_, 1 } @array1, @rray2; # create (key:$_, val:1) list for each item

# 2. and 3. need this
my @unique = keys %merged;

Hashes

%items = ('key1', 'val1', 'key2', 'val2');

%items = (
   key1 => 'val1', # keys auto quoted (same for $items{key1})
   key2 => 'val2'
);

while my ($key, $val) = each %items

References

make
$ref = \$@%named_variable;
$ref = [anonymous array]; # same brackets as for accessing elements
$ref = {anonymous hash};

use {$href} anywhere array/hash would be used ({}s are optional)
    @array: @$ref      or $ref->@*
     %hash: %$ref      or $ref->%*
 $array[3]: $$ref[3]   or $ref->[3] (note)
$hash{key}: $$ref{key} or $ref->{key}

(note) between 2 subscripts, -> is optional:
@array = ([...], [..x], [...]);
$$array[1][2] <=> $array[1]->[2] <=> $array[1][2]
                                 ... $hash{}{}

File test operators

if -d glob '~' # test if dir

Scope

my - lexical scope
our - same but alias for package var so can be accessed from outside
local - change separator (IFS: $/)

Regex

zero-width assertions don't consume chars => they are ANDed
hello(?=\d)(?!123) # followed by a number AND not followed by 123

Possessive quantifiers
no backtracking ~ don't give up characters

A++ is syntactic sugar for atomic group notation: (?>A+)

example:
"abcd =~ "[^"]+"
after matching "abcd, it's clear that no backtracking will change the fact that
a final " cannot be matched. Thus, in order to speedup failure, the pattern is
better rewritten as "[^"]++"

notes:
* "abcd" =~ "[^"]++" still matches.
* the optimizer would've automatically turned the regex possessive in this simple case.

backreferences
s/(\d+).\1/...$1/ # \1 and $1 represent the actual match, not \d+

# s///ms
$_ = qq/hello\nalien\nworld\n/
s/^.+$/---/m;  # multilines: match ^ and $ many times
s/lo.+wo/@@/s; # pretend $msg is a single line => . matches anything, including \ns

/o - check $var in pattern only once since we know it's not going to change

pre - $`, match - $&, post - $'

captures in list context
my ($ext) = $file =~ /\.(\w{3})/;
my @numbers = $version =~ /\d+/g;

//g - progressive matching

grep /pattern/, @array # match in list

Variables

local $/; # slurp file mode     # perl -0777
local $/ = ''; # paragraph mode # perl -00

Subroutines

&test {
# args in @_
wantarray ? @res : $res;
}

printf "I've got %d camel%s", $ARGV[0], $ARGV[0] == 1 ? '' : 's';

Notes

glob, <*> is safe for word splitting,
it's arguments only split on whitespace, not the returned files!
solutions: <"">, glob '""'

Use open/system/... with 3 args '-|', ... to:
- be protected against clobbering, code exe, ... (>, |, ... in $filename)
- avoid spawning a shell

Do not use -X file tests because of race conditions

Returns

chomp
grep
map
...

Functions

# sometimes printf is more readable
print 'Found a ', pos($i), "at\n";
printf "Found a %d at\n", pos($i);

sprintf is like printf but a string is returned instead of printed,
it can then be passed to functions such as 'say' which lack formatting capabilities.

sed vs perl
sed -ri 's/#(max_locks_per_transaction) = [0-9]+/\1 = 128/' postgresql.conf
perl -pi -e 's/#(max_locks_per_transaction) = \d+/$1 = 128/' postgresql.conf

perl vs awk
print from $3 to end
perl -laE 'say "@F[2..$#F]"' file # -a implies -n; -F implies -an

namei -l /path/to/file
perl -e '$_=shift; push @paths, $`.$& while m{.*?/(?!$)}g; system qq/ls -ld "$_"/ for @paths, $_' /path/to/file

BEGIN, END

# s//$1/
# without /e -> "" interpolation
#    with /e -> normal code:
#               $1 gets 'interpolated' by the first /e,
#               it's value (4 + 3) gets evaluated by the second /e!
$add = 4 + 3;
$_ = 'Sum: $add';
s/(\$\w+)/$1/ee;

Traps

always chomp with:
``, system, open, <STDIN>, perl -[np] (use -l)

__END__
