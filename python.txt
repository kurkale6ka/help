Variables are pointing to objects and objects can be of arbitrary data type,
thus variables cannot have types associated with them

x = 11, y = x => id(x) == id(y) (x is y)

' and " are equivalent
variable interpolation: f'Hello {var}' (or 'Hello {}'.format(var))

In interactive mode, the last printed expression is assigned to _

if 'yellow' in colors: # shorter/easier than
any(c == 'yellow' for c in colors)

(... for t in text if t.isalpha()) # could lead to a better solution than using
filter(str.isalpha, text)

  packing: assign to *t, we get a single tuple
unpacking:       use *t, we get all items

Decorators
Pass my function to a 'decorator' function, so it can apply it AND add extra
functionality, then return a new function to replace my initial one:

my_func = decorator(my_func) # which is what happens with:

@decorator
my_func(...)

Iterators
islice() parameters act similarly to range()'s ones,
the difference is we get an iterator, not a range.

groupby(iterable, key=None) # define a key per item (identity by default)
(key1, iterator1), ..., (keyN, iteratorN)

operator.itemgetter(0) is the same as lambda g: g[0]

venv: create isolated working copies of python with their own site packages.
This solves the problem of various python projects needing different versions
of the same 3rd party packages (aka site packages).

system wide python installation:
sudo pip install

isolated python installation:
pip install --user # without venv
pip install        # if using venv
