Scalars

my ($a, $b, $c) = @array; # multiple assignements

Arrays

@items = ('string', $scalar, 12);
@items = qw/one two three/;

@items # number of elements

@items[1..$#items] # slice: all bar 1st

@upper_case = map uc, @items; # change a list
@list = grep '[-_]', @items; # filter a list

shift, pop # remove elements
unshift, push # add elements

Hashes

%items = ('key1', 'val1', 'key2', 'val2');

%items = (
   key1 => 'val1', # keys auto quoted (same for $items{key1})
   key2 => 'val2'
);

while my ($key, $val) = each %items

References

make
$ref = \$@%named_variable;
$ref = [anonymous array];
$ref = {anonymous hash};

use {$href} anywhere array/hash would be used ({}s are optional)
      @array: @$ref
       %hash: %$ref
   $array[3]: $$ref[3]     or $ref->[3]*
$hash{'key'}: $$ref{'key'} or $ref->{'key'}

*between 2 subscripts, -> is optional:
@array = ([...], [..x], [...]);
$$array[1][2] <=> $array[1]->[2] <=> $array[1][2]
                                 ... $hash{}{}

File test operators

if -d glob '~' # test if dir

Scope

my - lexical scope
our - same but alias for package var so can be accessed from outside
local - change separator (IFS: $/)

Regex

s/(\d+)_(\1)_00/$1.$1.$1/; # 11_11_00 -> 11.11.11

$_ = qq/hello\nalien\nworld\n/
s/^.+$/---/m;  # multilines: match ^ and $ many times
s/lo.+wo/@@/s; # pretend $msg is a single line => . matches anything, including \ns

/o - check $var in pattern only once since we know it's not going to change

pre - $`, match - $&, post - $'

captures in list context
my ($ext) = $file =~ /\.(\w{3})/;
my @numbers = $version =~ /\d+/g;

//g - progressive matching

Subroutines

&test {
# args in @_
wantarray ? @res : $res;
}

open with 3 args '-|', ... to avoid shell param expansion

printf "I've got %d camel%s", $ARGV[0], $ARGV[0] == 1 ? '' : 's';

Are glob, <*...> safe for word splitting?

__END__
