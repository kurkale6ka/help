                                     Video

Frame rate:
-----------
the number of still pictures per unit of time of video
for good quality it must be >= 16

PAL   (Europe, Asia, Australia...)         25 frame/s
SECAM (France, Russia, parts of Africa...) 25 frame/s
NTSC  (USA, Canada, Japan...)              29.97 frame/s
are different color television standards

Aspect ratio:
-------------
width:height => 4:3, 16:9

Video compression:
------------------
image compression + motion compensation

* H.264/MPEG-4 Part 10 or AVC (Advanced Video Coding) is a video compression
  format, and is currently one of the most commonly used formats

* Xvid is a video codec which implements encoding and decoding videos using the
  MPEG-4 Part 2

Multimedia container formats
----------------------------
AVI, MP4, FLV, RealMedia, or Matroska
Such containers usually bundle both compressed video and audio streams (files)

      Codec                     encoders                      Containers
MPEG-2          |                                       |  .MPG
MPEG-4 Part 2   |  DivX, XviD (open), and Nero Digital  |  .AVI
MPEG-4 Part 10  |  x264, Mainconcept, QuickTime         |  .MP4, .MKV or .MOV

Note: MPEG-4 (AVC) or H.264 (this is the name of the standard)

A container will synchronize video and audio frames according to their
Presentation Time Stamp (PTS)

ffmpeg
======

Rotate:
-------
 90°: ffmpeg -i video.mp4 -c:a copy -vf 'transpose=1' out.mp4
180°: ffmpeg -i video.mp4 -c:a copy -vf 'transpose=1, transpose=1' out.mp4

All movies:
find . -iname 'video*.mp4' -print0 | parallel -0 ffmpeg -i {} -c:a copy -vf 'transpose=1' rotated/{}
or
parallel ffmpeg -i {} -c:a copy -vf 'transpose=1' rotated/{} ::: video*.mp4
if recursion (sub directories) isn't needed

Differentiate depending on rotation:
> /tmp/movies
for i in *.mov; do
   if [[ ! -e rotated/$i ]]
   then
      if command grep -q 'rotate=90' <(ffprobe -show_streams "$i" 2>&1)
      then
         echo "$i" >> /tmp/movies
      else
         ln -s "$i" rotated/
      fi
   fi
done
if [[ -s /tmp/movies ]]
then
   parallel ffmpeg -i {} -c:a copy -vf 'transpose=2' rotated/{} < /tmp/movies
fi

-c:(a|v) codec specifies the audio/video codec to use with copy meaning preserve
-vf stands for video filter (short for -filter:v)

Map:
----
a way to tell FFmpeg which streams you want to select/copy from input to output

Ex: extract audio streams:

Stream #0:0(eng): Video: h264 (High), yuv420p, 1920x800, 23.98 fps, 23.98 tbr, 1k tbn, 47.95 tbc (default)
Stream #0:1(ger): Audio: dts (DTS), 48000 Hz, 5.1(side), s16, 1536 kb/s (default)
Stream #0:2(eng): Audio: dts (DTS), 48000 Hz, 5.1(side), s16, 1536 kb/s
Stream #0:3(ger): Subtitle: text (default)

ffmpeg -i input.mkv -map 0:1 -map 0:2 -c copy output.mkv

Cutting small sections: (the following 2 are equivalent)
--------------------------------------------------------
ffmpeg -i video-in.mp4 -ss 11 -t 11 -c copy cut.mp4
ffmpeg -i video-in.mp4 -ss 11 -to 22 -c copy cut.mp4
-ss: seek
-t: duration
-to: position

Misc:
-----
%03d means a 3 digits number padded with 0s

Audio

Stereophonic sound creates an illusion of directionality and audible
perspective. Stereo uses an array of microphones (for true stereo) to capture
sound (1 channel per micro) and two or more loudspeakers are necessary in order
to recreate it. Simulated stereo is when a mono signal is manipulated by
software to create delays and changes in amplitude.
The reason we use stereo is because we have two ears thus we perceive sounds
with delay and pressure difference in each ear. Mono uses a single audio
channel.
