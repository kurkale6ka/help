YAML {{{1

List:
- item1
- item2

Mapping:
item1: value1
item2: value2

Anchors/aliases
&defaults (define an anchor)
*defaults (use the anchor)
'? ' -> complex mapping key

<< means “merge the given hash (mapping) into the current one”
Note: merging arrays is not possible, simple inheritance is supported,
      integration:
        *defaults

Vim: {{{1

:bun unload,          , :ls :ls!
:bd  unload,          ,  X  :ls!
:bw  unload, del marks,  X   X

cb^=unnamed:     y/d/c go to "" and "*
cb^=unnamedplus: y/d/c go to "" and "+

xargs and parallel {{{1

xargs    - execute command on arguments in bulk
parallel - execute command on arguments in parallel (and in bulk with -X)

Examples:
printf '%s ' 1 2 3 4 | xargs -n2 (default command is echo)
parallel echo ::: 1 2 3 4 # default command is bash not echo

parallel -X rm < file
Or
xargs rm < file # file with files to remove

find . -name '*.jpg' ! -path '*thumbs*' -print | parallel -X cp -a {} ~/Pictures/iphoto_lib

diff: unified format {{{1

--- /path/to/old    <tab> ''timestamp''
+++ /path/to/new    <tab> ''timestamp''
@@ -1,3 +1,8 @@           => -1 means first line in old file
+ This is an important        3 = sum of contextual lines + -s in this hunk
+ notice! It should          +1 means first line in new file
+ therefore be located at     8 = sum of contextual lines + +s in this hunk
+                             - line: only present in old file
  This part of the            + line: only present in new file
- document has stayed the
  same from version to
+ the beginning of this
+ document!

Remove dependencies with yum: {{{1

yum install rkhunter
yum history list rkhunter
yum history undo 304

Zombies {{{1

You can’t kill a zombie process because it’s already dead. Zombies are
basically dead processes that haven’t been cleaned up. The child notifies his
parent that it has terminated, with the SIGCHLD signal. The parent then is
supposed to call wait() in order to gather info from the dead process. After
wait() is called, the zombie process is completely removed from memory. Zombies
keep a descriptor in memory + they preserve their PIDs. Zombies are harmless
unless there are so many it results in a shortage of PIDs.

Solutions:
* Resend SIGCHLD
* Kill the parent which will make init the new parent and rely on init to call
  wait() which it does periodically
* Reprogram the parent so it doesn't ignore SIGCHLD and calls wait()

curl {{{1

        data transfer (ftp, http, pop, ldap...)
curl <-------------------------------------------> server
        http://site.{one,two,three}.com, ftp://ftp.numericals.com/file[1-100:2].txt

-A <user-agent>

DNS {{{1

$ORIGIN uk.example.com. (@ used as an alias)
ftp  IN   A   10.0.16.34 => not ftp. so ftp.uk.example.com.

dig @8.8.8.8 redhat.com mx +short centos.org cname
dig -x 209.132.183.81
Note: a/cname/mx/ns
     (default NS server chosen from /etc/resolv.conf)

Bash {{{1

parent shell PID: $$, current subshell: BASHPID

quotes:
Q. In FAQ096, why is this ok? ssh localhost '~/bin/args make CFLAGS="-g -O"'
   Why do we end up with 2 args and not 3 because of remote word splitting?
A. it gets parsed by the local shell, then the remote shell
   it'll run                             "$SHELL" -c '~/bin/args make CFLAGS="-g -O"' on the remote end
   if you omit the '' quotes, it'll run  "$SHELL" -c '/home/localhomedir/bin/args make CFLAGS=-g -O'

Nesting single quotes:
   ssh 'grep -iE '\''blah'\'' file'
1. ssh 'grep -iE '  'blah'  ' file' -> break it in 3 sets of quotes
2.                \''blah'\'        -> use literal 's that bash won't parse
   ssh grep -iE 'blah' file         -> our remote command

completion:
complete -d -Fmyfunc cd: cd will use myfunc and dir completion
compgen -d m: generate completion list of dirs    named m... (<=> -Adirectory)
compgen -a m: generate completion list of aliases named m...
compgen must put the possible completions in the COMPREPLY array
COMP_WORDS: command line args during completion - [ cd m ]<tab>
COMP_CWORD: index in COMP_WORDS of the word containing the cursor

man issues {{{1

LESS= man manpage # -F was the problem
nroff -man <(zcat /usr/share/man/man1/env.1.gz) | LESS= less
groff -man -Tascii <(zcat /usr/share/man/man1/env.1.gz) | LESS= less

Android PnP (gvfs-mtp:) {{{1

mount -tfuse.gvfsd-fuse
rsync -aun --progress /run/user/1000/gvfs/mtp\:host\=%5Busb%3A002%2C006%5D/Card/DCIM/Camera/ ~/dest/ > /tmp/copy
parallel -a /tmp/copy gvfs-copy mtp://[usb:002,006]/Card/DCIM/Camera/{} ~/dest/

Ruby {{{1
----

Rack Servers
============

Rack provides a minimal interface between webservers supporting Ruby and Ruby frameworks

Phusion Passenger (mod_rails, mod_rack) is a free web server and application
server with support for Ruby, Python and Node.js. It is designed to integrate
into the Apache HTTP Server or the nginx web server. It supports arbitrary Ruby
web frameworks through the Rack interface

Unicorn is an HTTP server for Rack applications designed to only serve fast
clients on low-latency, high-bandwidth connections and take advantage of
features in Unix/Unix-like kernels

Bundler
=======

Ensure a bundle of gems get installed at their expected versions.

gem install bundler

Gemfile:
gem "nokogiri", "~> 1.4.4" # I want nokogiri as long as it’s greater than version 1.4.4

bundle install will install the latest stable version of nokogiri in this case.
Using Gemfile.lock, we make sure, say, version 1.5.3 gets installed.

So first, Gemfile.lock gets created after running bundle install, then it gets
used for all subsequent runs of bundle install!

bundle exec executes a script using the gems specified in the script's Gemfile
rather than the systemwide Gemfile

lsof, nodejs {{{1

lsof -i :6667

Node.js - a V8 js platform which allows to build server/client apps all in js
          ex of such an app: statsd

Host controller {{{1
---------------

        host controller           network
host    host adapter              storage devices (usb: xhci, sata: ahci)
        host bus adapter (HBA)
        (PCI cards or directly on the mobo: usb, sata)

cron {{{1
----

anacron:
nb-days | delay after start | job-identifier | command
 |         |                   |
 |         |                   name for the job’s timestamp file (ex: /var/spool/anacron/fstrim.daily)
 |         minutes to wait before executing the job after the machine starts
 7 (@weekly)

cron:
minute | hour | day_of_month | month | day_of_week | command

# vim: foldmethod=marker foldmarker={{{,}}}
